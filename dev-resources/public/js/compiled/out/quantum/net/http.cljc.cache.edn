;; Analyzed by ClojureScript 1.7.170
{:use-macros {def- quantum.core.ns, whenf*n quantum.core.logic, doto->> quantum.core.function, try-times quantum.core.error, condfc quantum.core.logic, f*n quantum.core.function, coll-and quantum.core.logic, try+ quantum.core.error, fn-not quantum.core.logic, defcurried quantum.core.function, ifn quantum.core.logic, defalias quantum.core.ns, whencf*n quantum.core.logic, with-do quantum.core.function, <- quantum.core.function, whenc quantum.core.logic, throw-when quantum.core.error, ifp quantum.core.logic, assertf-> quantum.core.error, fn-or quantum.core.logic, if*n quantum.core.logic, fn-eq? quantum.core.logic, condf*n quantum.core.logic, ns-exclude quantum.core.ns, coll-or quantum.core.logic, assertf->> quantum.core.error, fn-and quantum.core.logic, defonce quantum.core.ns, fn-> quantum.core.function, rfn quantum.core.function, throw+ quantum.core.error, source quantum.core.ns, condpc quantum.core.logic, fn= quantum.core.logic, assert quantum.core.error, throw-unless quantum.core.error, whenp quantum.core.logic, whenf quantum.core.logic, eq? quantum.core.logic, with-assert quantum.core.error, condf quantum.core.logic, fn->> quantum.core.function}, :excludes #{defonce assert}, :name quantum.net.http, :imports nil, :requires {clojure.core.rrb-vector clojure.core.rrb-vector, logic quantum.core.logic, cljs.core cljs.core, ws taoensso.sente, fn quantum.core.function, ns quantum.core.ns, quantum.core.logic quantum.core.logic, err quantum.core.error, com.stuartsierra.component com.stuartsierra.component, taoensso.sente taoensso.sente, component com.stuartsierra.component, quantum.core.error quantum.core.error, quantum.core.ns quantum.core.ns, core cljs.core, quantum.core.function quantum.core.function}, :uses {AMap quantum.core.ns, juxtm quantum.core.function, juxt-kv quantum.core.function, any? quantum.core.logic, AArrList quantum.core.ns, firsta quantum.core.function, *fn quantum.core.function, Err quantum.core.error, ABool quantum.core.ns, ATreeMap quantum.core.ns, js-println quantum.core.ns, IllegalArgumentException quantum.core.ns, ASet quantum.core.ns, with-pr->> quantum.core.function, nnil? quantum.core.logic, ALSeq quantum.core.ns, ARegex quantum.core.ns, with->> quantum.core.function, call quantum.core.function, AExactNum quantum.core.ns, AEditable quantum.core.ns, zeroid quantum.core.function, AKey quantum.core.ns, splice-or quantum.core.logic, with-msg->> quantum.core.function, compr quantum.core.function, AQueue quantum.core.ns, AError quantum.core.ns, fn-nil quantum.core.function, ADouble quantum.core.ns, withfs quantum.core.function, AVec quantum.core.ns, ->ex quantum.core.error, ADecimal quantum.core.ns, Exception quantum.core.ns, AInt quantum.core.ns, monoid quantum.core.function, ATransient quantum.core.ns, withf quantum.core.function, nempty? quantum.core.logic, ANum quantum.core.ns, ANil quantum.core.ns, unary quantum.core.function, withf->> quantum.core.function}, :defs {valid-port? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/http.cljc", :line 8, :column 7, :end-line 8, :end-column 18, :arglists (quote ([x]))}, :name quantum.net.http/valid-port?, :variadic false, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/http.cljc", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 8, :end-line 8, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, ChannelSocket {:num-fields 14, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative com.stuartsierra.component/Lifecycle cljs.core/IMap cljs.core/ILookup}, :name quantum.net.http/ChannelSocket, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/http.cljc", :end-column 16, :type true, :column 3, :internal-ctor true, :usage (quote (map->ChannelSocket {:uri "/chan", :packer :edn, :msg-handler my-msg-handler})), :line 24, :record true, :end-line 24, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "A WebSocket-channel abstraction of Sente's functionality.\n\n          Creates a Sente WebSocket channel and Sente WebSocket channel\n          message router.\n\n          @chan-recv  : ChannelSocket's receive channel\n          @chan-send! : ChannelSocket's send API fn\n          @chan-state : Watchable, read-only atom\n          @packer     : Client<->server serialization format"}, ->ChannelSocket {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/http.cljc", :end-column 16, :column 3, :internal-ctor true, :factory :positional, :usage (quote (map->ChannelSocket {:uri "/chan", :packer :edn, :msg-handler my-msg-handler})), :line 24, :end-line 24, :arglists (quote ([uri host chan chan-recv send-fn chan-state type server-type packer stop-fn ajax-post-fn ajax-get-or-ws-handshake-fn msg-handler connected-uids])), :doc "A WebSocket-channel abstraction of Sente's functionality.\n\n          Creates a Sente WebSocket channel and Sente WebSocket channel\n          message router.\n\n          @chan-recv  : ChannelSocket's receive channel\n          @chan-send! : ChannelSocket's send API fn\n          @chan-state : Watchable, read-only atom\n          @packer     : Client<->server serialization format"}, :name quantum.net.http/->ChannelSocket, :variadic false, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/http.cljc", :end-column 16, :method-params ([uri host chan chan-recv send-fn chan-state type server-type packer stop-fn ajax-post-fn ajax-get-or-ws-handshake-fn msg-handler connected-uids]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :usage (quote (map->ChannelSocket {:uri "/chan", :packer :edn, :msg-handler my-msg-handler})), :line 11, :end-line 24, :max-fixed-arity 14, :fn-var true, :arglists (quote ([uri host chan chan-recv send-fn chan-state type server-type packer stop-fn ajax-post-fn ajax-get-or-ws-handshake-fn msg-handler connected-uids])), :doc "A WebSocket-channel abstraction of Sente's functionality.\n\n          Creates a Sente WebSocket channel and Sente WebSocket channel\n          message router.\n\n          @chan-recv  : ChannelSocket's receive channel\n          @chan-send! : ChannelSocket's send API fn\n          @chan-state : Watchable, read-only atom\n          @packer     : Client<->server serialization format"}, map->ChannelSocket {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/http.cljc", :end-column 16, :column 3, :internal-ctor true, :factory :map, :usage (quote (map->ChannelSocket {:uri "/chan", :packer :edn, :msg-handler my-msg-handler})), :line 24, :end-line 24, :arglists (quote ([G__28435])), :doc "A WebSocket-channel abstraction of Sente's functionality.\n\n          Creates a Sente WebSocket channel and Sente WebSocket channel\n          message router.\n\n          @chan-recv  : ChannelSocket's receive channel\n          @chan-send! : ChannelSocket's send API fn\n          @chan-state : Watchable, read-only atom\n          @packer     : Client<->server serialization format"}, :name quantum.net.http/map->ChannelSocket, :variadic false, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/http.cljc", :end-column 16, :method-params ([G__28435]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :usage (quote (map->ChannelSocket {:uri "/chan", :packer :edn, :msg-handler my-msg-handler})), :line 11, :end-line 24, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__28435])), :doc "A WebSocket-channel abstraction of Sente's functionality.\n\n          Creates a Sente WebSocket channel and Sente WebSocket channel\n          message router.\n\n          @chan-recv  : ChannelSocket's receive channel\n          @chan-send! : ChannelSocket's send API fn\n          @chan-state : Watchable, read-only atom\n          @packer     : Client<->server serialization format"}}, :require-macros {fn quantum.core.function, quantum.core.function quantum.core.function, logic quantum.core.logic, quantum.core.logic quantum.core.logic, err quantum.core.error, quantum.core.error quantum.core.error, ns quantum.core.ns, quantum.core.ns quantum.core.ns}, :cljs.analyzer/constants {:seen #{send-fn uri server-type :ajax-post-fn :chan :ws :ch-recv :connected-uids ajax-post-fn chan :packer :stop-fn :type :state :ajax connected-uids :chan-recv packer :ajax-get-or-ws-handshake-fn :msg-handler stop-fn :host type :chan-state ajax-get-or-ws-handshake-fn msg-handler chan-recv :chsk :assertion-error host :server-type :send-fn :uri :auto chan-state}, :order [:uri :host :chan :chan-recv :send-fn :chan-state :type :server-type :packer :stop-fn :ajax-post-fn :ajax-get-or-ws-handshake-fn :msg-handler :connected-uids :assertion-error uri :auto :chsk :ch-recv :state :ws :ajax host chan chan-recv send-fn chan-state type server-type packer stop-fn ajax-post-fn ajax-get-or-ws-handshake-fn msg-handler connected-uids]}, :doc nil}