;; Analyzed by ClojureScript 1.7.170
{:use-macros {def- quantum.core.ns, with-resources quantum.core.resources, whenf*n quantum.core.logic, wait-until quantum.core.thread.async, doto->> quantum.core.function, try-times quantum.core.error, condfc quantum.core.logic, f*n quantum.core.function, coll-and quantum.core.logic, go cljs.core.async.macros, try+ quantum.core.error, fn-not quantum.core.logic, defcurried quantum.core.function, ifn quantum.core.logic, defalias quantum.core.ns, whencf*n quantum.core.logic, with-do quantum.core.function, <- quantum.core.function, whenc quantum.core.logic, go-loop cljs.core.async.macros, throw-when quantum.core.error, ifp quantum.core.logic, assertf-> quantum.core.error, fn-or quantum.core.logic, if*n quantum.core.logic, fn-eq? quantum.core.logic, condf*n quantum.core.logic, ns-exclude quantum.core.ns, kmap quantum.core.collections.base, coll-or quantum.core.logic, assertf->> quantum.core.error, fn-and quantum.core.logic, defonce quantum.core.ns, fn-> quantum.core.function, rfn quantum.core.function, throw+ quantum.core.error, source quantum.core.ns, condpc quantum.core.logic, fn= quantum.core.logic, assert quantum.core.error, throw-unless quantum.core.error, whenp quantum.core.logic, whenf quantum.core.logic, eq? quantum.core.logic, with-assert quantum.core.error, condf quantum.core.logic, fn->> quantum.core.function}, :excludes #{defonce assert}, :name quantum.net.websocket, :imports nil, :requires {quantum.core.core quantum.core.core, res quantum.core.resources, core-async cljs.core.async, clojure.core.rrb-vector clojure.core.rrb-vector, logic quantum.core.logic, log quantum.core.log, async quantum.core.thread.async, cljs.core cljs.core, ws taoensso.sente, fn quantum.core.function, quantum.core.log quantum.core.log, cljs.core.async cljs.core.async, quantum.core.resources quantum.core.resources, ns quantum.core.ns, quantum.core.logic quantum.core.logic, err quantum.core.error, taoensso.sente taoensso.sente, quantum.core.thread.async quantum.core.thread.async, quantum.core.error quantum.core.error, quantum.core.ns quantum.core.ns, core cljs.core, quantum.core.function quantum.core.function}, :uses {AMap quantum.core.ns, take!! quantum.core.thread.async, juxtm quantum.core.function, concur quantum.core.thread.async, juxt-kv quantum.core.function, <! cljs.core.async, any? quantum.core.logic, AArrList quantum.core.ns, firsta quantum.core.function, *fn quantum.core.function, Err quantum.core.error, ABool quantum.core.ns, ATreeMap quantum.core.ns, chan quantum.core.thread.async, js-println quantum.core.ns, IllegalArgumentException quantum.core.ns, >!! quantum.core.thread.async, ASet quantum.core.ns, with-pr->> quantum.core.function, nnil? quantum.core.logic, ALSeq quantum.core.ns, ARegex quantum.core.ns, with->> quantum.core.function, call quantum.core.function, AExactNum quantum.core.ns, put!! quantum.core.thread.async, AEditable quantum.core.ns, zeroid quantum.core.function, AKey quantum.core.ns, deref* quantum.core.core, splice-or quantum.core.logic, with-msg->> quantum.core.function, lens quantum.core.core, <!! quantum.core.thread.async, compr quantum.core.function, AQueue quantum.core.ns, peek!! quantum.core.thread.async, AError quantum.core.ns, fn-nil quantum.core.function, ADouble quantum.core.ns, withfs quantum.core.function, >! cljs.core.async, AVec quantum.core.ns, ->ex quantum.core.error, ADecimal quantum.core.ns, alts! cljs.core.async, Exception quantum.core.ns, empty! quantum.core.thread.async, AInt quantum.core.ns, monoid quantum.core.function, ATransient quantum.core.ns, withf quantum.core.function, alts!! quantum.core.thread.async, nempty? quantum.core.logic, ANum quantum.core.ns, ANil quantum.core.ns, unary quantum.core.function, withf->> quantum.core.function, with-cleanup quantum.core.resources}, :defs {event-msg-handler {:name quantum.net.websocket/event-msg-handler, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :line 12, :column 1, :end-line 12, :end-column 28, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :line 12, :column 11, :end-line 12, :end-column 28}}, send-msg! {:name quantum.net.websocket/send-msg!, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :line 13, :column 1, :end-line 13, :end-column 15, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :line 13, :column 6, :end-line 13, :end-column 15}}, event-msg-handler* {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :line 16, :column 11, :end-line 16, :end-column 29, :arglists (quote ([{:as ev-msg, :keys [id ?data event]}]))}, :name quantum.net.websocket/event-msg-handler*, :variadic false, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :end-column 29, :method-params ([p__28874]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 16, :end-line 16, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{:as ev-msg, :keys [id ?data event]}]))}, put! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :line 83, :column 7, :end-line 83, :end-column 11, :arglists (quote ([[msg-id msg] callback & [timeout]])), :doc "Sends a message @msg across via a WebSocket connection.", :usage (quote (put! :my/button {:my-key1 "Data1", :my-key2 "Data2"} (fn [resp] (println "Response is" resp)) 100)), :top-fn {:variadic true, :max-fixed-arity 2, :method-params [([msg-id msg] callback [timeout])], :arglists ([[msg-id msg] callback & [timeout]]), :arglists-meta (nil)}}, :name quantum.net.websocket/put!, :variadic true, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [([msg-id msg] callback [timeout])], :arglists ([[msg-id msg] callback & [timeout]]), :arglists-meta (nil)}, :method-params [([msg-id msg] callback [timeout])], :protocol-impl nil, :arglists-meta (nil), :column 1, :usage (quote (put! :my/button {:my-key1 "Data1", :my-key2 "Data2"} (fn [resp] (println "Response is" resp)) 100)), :line 83, :end-line 83, :max-fixed-arity 2, :fn-var true, :arglists ([[msg-id msg] callback & [timeout]]), :doc "Sends a message @msg across via a WebSocket connection."}, try-put! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :line 94, :column 7, :end-line 94, :end-column 15, :arglists (quote ([?times ?sleep & args])), :doc "Try to send messsage @?times times with intervals of @?sleep\n   milliseconds. As soon as message send is successful, no further\n   messages are tried to be sent.", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(?times ?sleep args)], :arglists ([?times ?sleep & args]), :arglists-meta (nil)}}, :name quantum.net.websocket/try-put!, :variadic true, :file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/net/websocket.cljc", :end-column 15, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(?times ?sleep args)], :arglists ([?times ?sleep & args]), :arglists-meta (nil)}, :method-params [(?times ?sleep args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 94, :end-line 94, :max-fixed-arity 2, :fn-var true, :arglists ([?times ?sleep & args]), :doc "Try to send messsage @?times times with intervals of @?sleep\n   milliseconds. As soon as message send is successful, no further\n   messages are tried to be sent."}}, :require-macros {res quantum.core.resources, logic quantum.core.logic, cljs.core.async.macros cljs.core.async.macros, log quantum.core.log, async quantum.core.thread.async, fn quantum.core.function, quantum.core.log quantum.core.log, quantum.core.resources quantum.core.resources, ns quantum.core.ns, quantum.core.logic quantum.core.logic, err quantum.core.error, asyncm cljs.core.async.macros, quantum.core.thread.async quantum.core.thread.async, quantum.core.error quantum.core.error, quantum.core.collections.base quantum.core.collections.base, quantum.core.ns quantum.core.ns, quantum.core.function quantum.core.function}, :cljs.analyzer/constants {:seen #{:tries :first-open? :chsk/recv :last-error :sys-map :else :default :recur :chsk/state :debug :max-tries-exceeded :event :id :epimaxsa.match424.common.system/system :?data :assertion-error :send-fn :hierarchy :connection :chsk/handshake}, :order [:hierarchy :id :default :send-fn :connection :sys-map :epimaxsa.match424.common.system/system :?data :event :debug :chsk/state :first-open? :chsk/recv :chsk/handshake :assertion-error :else :recur :tries :last-error :max-tries-exceeded]}, :doc nil}