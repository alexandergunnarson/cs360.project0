;; Analyzed by ClojureScript 1.7.170
{:use-macros {def- quantum.core.ns, whenf*n quantum.core.logic, doto->> quantum.core.function, condfc quantum.core.logic, f*n quantum.core.function, coll-and quantum.core.logic, fn-not quantum.core.logic, defcurried quantum.core.function, ifn quantum.core.logic, defalias quantum.core.ns, whencf*n quantum.core.logic, with-do quantum.core.function, <- quantum.core.function, whenc quantum.core.logic, ifp quantum.core.logic, fn-or quantum.core.logic, if*n quantum.core.logic, fn-eq? quantum.core.logic, condf*n quantum.core.logic, ns-exclude quantum.core.ns, coll-or quantum.core.logic, fn-and quantum.core.logic, defonce quantum.core.ns, fn-> quantum.core.function, rfn quantum.core.function, source quantum.core.ns, condpc quantum.core.logic, fn= quantum.core.logic, whenp quantum.core.logic, whenf quantum.core.logic, eq? quantum.core.logic, condf quantum.core.logic, fn->> quantum.core.function}, :excludes #{name}, :name quantum.core.analyze.clojure.predicates, :imports nil, :requires {clojure.core.rrb-vector clojure.core.rrb-vector, logic quantum.core.logic, cljs.core cljs.core, fn quantum.core.function, ns quantum.core.ns, quantum.core.logic quantum.core.logic, tcore quantum.core.type.core, quantum.core.type.core quantum.core.type.core, str clojure.string, clojure.string clojure.string, quantum.core.ns quantum.core.ns, core cljs.core, quantum.core.function quantum.core.function}, :uses {AMap quantum.core.ns, juxtm quantum.core.function, juxt-kv quantum.core.function, any? quantum.core.logic, AArrList quantum.core.ns, firsta quantum.core.function, *fn quantum.core.function, ABool quantum.core.ns, ATreeMap quantum.core.ns, js-println quantum.core.ns, IllegalArgumentException quantum.core.ns, ASet quantum.core.ns, with-pr->> quantum.core.function, nnil? quantum.core.logic, ALSeq quantum.core.ns, ARegex quantum.core.ns, with->> quantum.core.function, call quantum.core.function, AExactNum quantum.core.ns, AEditable quantum.core.ns, zeroid quantum.core.function, AKey quantum.core.ns, splice-or quantum.core.logic, with-msg->> quantum.core.function, compr quantum.core.function, AQueue quantum.core.ns, AError quantum.core.ns, fn-nil quantum.core.function, ADouble quantum.core.ns, withfs quantum.core.function, AVec quantum.core.ns, ADecimal quantum.core.ns, Exception quantum.core.ns, AInt quantum.core.ns, monoid quantum.core.function, ATransient quantum.core.ns, withf quantum.core.function, nempty? quantum.core.logic, ANum quantum.core.ns, ANil quantum.core.ns, unary quantum.core.function, withf->> quantum.core.function}, :defs {form-and-begins-with? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 73, :column 7, :end-line 73, :end-column 28, :arglists (quote ([sym]))}, :name quantum.core.analyze.clojure.predicates/form-and-begins-with?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 28, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 73, :end-line 73, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, branching-syms {:name quantum.core.analyze.clojure.predicates/branching-syms, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 111, :column 1, :end-line 111, :end-column 20, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 111, :column 6, :end-line 111, :end-column 20}}, do-statement? {:name quantum.core.analyze.clojure.predicates/do-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 103, :column 1, :end-line 103, :end-column 19, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 103, :column 6, :end-line 103, :end-column 19}}, s-expr? {:name quantum.core.analyze.clojure.predicates/s-expr?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 86, :column 1, :end-line 86, :end-column 18, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 86, :column 11, :end-line 86, :end-column 18}}, qualified? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 32, :column 7, :end-line 32, :end-column 17, :arglists (quote ([sym]))}, :name quantum.core.analyze.clojure.predicates/qualified?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 17, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 32, :end-line 32, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, return-statement? {:name quantum.core.analyze.clojure.predicates/return-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 97, :column 1, :end-line 97, :end-column 23, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 97, :column 6, :end-line 97, :end-column 23}}, variadic-arglist? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 58, :column 6, :end-line 58, :end-column 23}, :name quantum.core.analyze.clojure.predicates/variadic-arglist?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 23, :method-params ([x__25385__auto__]), :protocol-impl nil, :arglists-meta (), :column 1, :line 58, :end-line 58, :max-fixed-arity 1, :fn-var true, :arglists nil}, sym-call? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 85, :column 6, :end-line 85, :end-column 15}, :name quantum.core.analyze.clojure.predicates/sym-call?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 15, :method-params ([G__33665]), :protocol-impl nil, :arglists-meta (), :column 1, :line 85, :end-line 85, :max-fixed-arity 1, :fn-var true, :arglists nil}, many-branched? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 122, :column 6, :end-line 122, :end-column 20}, :name quantum.core.analyze.clojure.predicates/many-branched?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 20, :method-params ([G__33684]), :protocol-impl nil, :arglists-meta (), :column 1, :line 122, :end-line 122, :max-fixed-arity 1, :fn-var true, :arglists nil}, str-expression? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 80, :column 6, :end-line 80, :end-column 21}, :name quantum.core.analyze.clojure.predicates/str-expression?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 21, :method-params ([G__33663]), :protocol-impl nil, :arglists-meta (), :column 1, :line 80, :end-line 80, :max-fixed-arity 1, :fn-var true, :arglists nil}, function-statement? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 100, :column 6, :end-line 100, :end-column 25}, :name quantum.core.analyze.clojure.predicates/function-statement?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 25, :method-params ([G__33668]), :protocol-impl nil, :arglists-meta (), :column 1, :line 100, :end-line 100, :max-fixed-arity 1, :fn-var true, :arglists nil}, throw-statement? {:name quantum.core.analyze.clojure.predicates/throw-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 107, :column 1, :end-line 107, :end-column 22, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 107, :column 6, :end-line 107, :end-column 22}}, conditional-statement? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 126, :column 6, :end-line 126, :end-column 28}, :name quantum.core.analyze.clojure.predicates/conditional-statement?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 28, :method-params ([G__33691]), :protocol-impl nil, :arglists-meta (), :column 1, :line 126, :end-line 126, :max-fixed-arity 1, :fn-var true, :arglists nil}, arglist-arity {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 65, :column 6, :end-line 65, :end-column 19}, :name quantum.core.analyze.clojure.predicates/arglist-arity, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 19, :method-params ([arg__25729__auto__]), :protocol-impl nil, :arglists-meta (), :column 1, :line 65, :end-line 65, :max-fixed-arity 1, :fn-var true, :arglists nil}, possible-type-predicate? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 36, :column 6, :end-line 36, :end-column 30}, :name quantum.core.analyze.clojure.predicates/possible-type-predicate?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 30, :method-params ([G__33651]), :protocol-impl nil, :arglists-meta (), :column 1, :line 36, :end-line 36, :max-fixed-arity 1, :fn-var true, :arglists nil}, cond-foldable? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 127, :column 6, :end-line 127, :end-column 20}, :name quantum.core.analyze.clojure.predicates/cond-foldable?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 20, :method-params ([G__33692]), :protocol-impl nil, :arglists-meta (), :column 1, :line 127, :end-line 127, :max-fixed-arity 1, :fn-var true, :arglists nil}, shadows-var? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 43, :column 7, :end-line 43, :end-column 19, :arglists (quote ([bindings v]))}, :name quantum.core.analyze.clojure.predicates/shadows-var?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 19, :method-params ([bindings v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 43, :end-line 43, :max-fixed-arity 2, :fn-var true, :arglists (quote ([bindings v]))}, symbol-eq? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 30, :column 7, :end-line 30, :end-column 17, :arglists (quote ([s1 s2]))}, :name quantum.core.analyze.clojure.predicates/symbol-eq?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 17, :method-params ([s1 s2]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 30, :end-line 30, :max-fixed-arity 2, :fn-var true, :arglists (quote ([s1 s2]))}, name {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 12, :column 7, :end-line 12, :end-column 11, :arglists (quote ([x]))}, :name quantum.core.analyze.clojure.predicates/name, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 11, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 12, :end-line 12, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, first-variadic? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 57, :column 6, :end-line 57, :end-column 21}, :name quantum.core.analyze.clojure.predicates/first-variadic?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 21, :method-params ([x__25385__auto__]), :protocol-impl nil, :arglists-meta (), :column 1, :line 57, :end-line 57, :max-fixed-arity 1, :fn-var true, :arglists nil}, when-statement? {:name quantum.core.analyze.clojure.predicates/when-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 106, :column 1, :end-line 106, :end-column 21, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 106, :column 6, :end-line 106, :end-column 21}}, scope? {:name quantum.core.analyze.clojure.predicates/scope?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 101, :column 1, :end-line 101, :end-column 12, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 101, :column 6, :end-line 101, :end-column 12}}, form-and-begins-with-any? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 75, :column 7, :end-line 75, :end-column 32, :arglists (quote ([set-n]))}, :name quantum.core.analyze.clojure.predicates/form-and-begins-with-any?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 32, :method-params ([set-n]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 75, :end-line 75, :max-fixed-arity 1, :fn-var true, :arglists (quote ([set-n]))}, let-statement? {:name quantum.core.analyze.clojure.predicates/let-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 102, :column 1, :end-line 102, :end-column 20, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 102, :column 6, :end-line 102, :end-column 20}}, hinted-literal? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 39, :column 6, :end-line 39, :end-column 21}, :name quantum.core.analyze.clojure.predicates/hinted-literal?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 21, :method-params ([G__33656]), :protocol-impl nil, :arglists-meta (), :column 1, :line 39, :end-line 39, :max-fixed-arity 1, :fn-var true, :arglists nil}, two-branched? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 119, :column 6, :end-line 119, :end-column 19}, :name quantum.core.analyze.clojure.predicates/two-branched?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 19, :method-params ([G__33677]), :protocol-impl nil, :arglists-meta (), :column 1, :line 119, :end-line 119, :max-fixed-arity 1, :fn-var true, :arglists nil}, string-concatable? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 81, :column 6, :end-line 81, :end-column 24}, :name quantum.core.analyze.clojure.predicates/string-concatable?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 24, :method-params ([G__33664]), :protocol-impl nil, :arglists-meta (), :column 1, :line 81, :end-line 81, :max-fixed-arity 1, :fn-var true, :arglists nil}, cond-statement? {:name quantum.core.analyze.clojure.predicates/cond-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 105, :column 1, :end-line 105, :end-column 21, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 105, :column 6, :end-line 105, :end-column 21}}, constructor? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 95, :column 6, :end-line 95, :end-column 18}, :name quantum.core.analyze.clojure.predicates/constructor?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 18, :method-params ([G__33667]), :protocol-impl nil, :arglists-meta (), :column 1, :line 95, :end-line 95, :max-fixed-arity 1, :fn-var true, :arglists nil}, unqualify {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 33, :column 7, :end-line 33, :end-column 16, :arglists (quote ([sym]))}, :name quantum.core.analyze.clojure.predicates/unqualify, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 16, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 33, :end-line 33, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}, type-hint {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 15, :column 7, :end-line 15, :end-column 16, :arglists (quote ([x])), :doc "Returns a symbol representing the tagged class of the symbol, or |nil| if none exists.", :source "ztellman/riddley.compiler"}, :name quantum.core.analyze.clojure.predicates/type-hint, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 16, :method-params ([x]), :protocol-impl nil, :source "ztellman/riddley.compiler", :arglists-meta (nil nil), :column 1, :line 15, :end-line 15, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x])), :doc "Returns a symbol representing the tagged class of the symbol, or |nil| if none exists."}, defn-statement? {:name quantum.core.analyze.clojure.predicates/defn-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 98, :column 1, :end-line 98, :end-column 21, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 98, :column 6, :end-line 98, :end-column 21}}, arity-type {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 60, :column 7, :end-line 60, :end-column 17, :arglists (quote ([arglist]))}, :name quantum.core.analyze.clojure.predicates/arity-type, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 17, :method-params ([arglist]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 60, :end-line 60, :max-fixed-arity 1, :fn-var true, :arglists (quote ([arglist]))}, fn-statement? {:name quantum.core.analyze.clojure.predicates/fn-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 99, :column 1, :end-line 99, :end-column 19, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 99, :column 6, :end-line 99, :end-column 19}}, one-branched? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 116, :column 6, :end-line 116, :end-column 19}, :name quantum.core.analyze.clojure.predicates/one-branched?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 19, :method-params ([G__33670]), :protocol-impl nil, :arglists-meta (), :column 1, :line 116, :end-line 116, :max-fixed-arity 1, :fn-var true, :arglists nil}, branching-expr? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 113, :column 6, :end-line 113, :end-column 21}, :name quantum.core.analyze.clojure.predicates/branching-expr?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 21, :method-params ([G__33669]), :protocol-impl nil, :arglists-meta (), :column 1, :line 113, :end-line 113, :max-fixed-arity 1, :fn-var true, :arglists nil}, new-scope? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 50, :column 6, :end-line 50, :end-column 16}, :name quantum.core.analyze.clojure.predicates/new-scope?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 16, :method-params ([G__33657]), :protocol-impl nil, :arglists-meta (), :column 1, :line 50, :end-line 50, :max-fixed-arity 1, :fn-var true, :arglists nil}, else-pred? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 78, :column 6, :end-line 78, :end-column 16}, :name quantum.core.analyze.clojure.predicates/else-pred?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 16, :method-params ([G__33662]), :protocol-impl nil, :arglists-meta (), :column 1, :line 78, :end-line 78, :max-fixed-arity 1, :fn-var true, :arglists nil}, if-statement? {:name quantum.core.analyze.clojure.predicates/if-statement?, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 104, :column 1, :end-line 104, :end-column 19, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 104, :column 6, :end-line 104, :end-column 19}}, auto-genned? {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/analyze/clojure/predicates.cljc", :line 34, :column 7, :end-line 34, :end-column 19, :arglists (quote ([sym]))}, :name quantum.core.analyze.clojure.predicates/auto-genned?, :variadic false, :file "src/cljc/quantum/core/analyze/clojure/predicates.cljc", :end-column 19, :method-params ([sym]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 34, :end-line 34, :max-fixed-arity 1, :fn-var true, :arglists (quote ([sym]))}}, :require-macros {fn quantum.core.function, quantum.core.function quantum.core.function, logic quantum.core.logic, quantum.core.logic quantum.core.logic, ns quantum.core.ns, quantum.core.ns quantum.core.ns}, :cljs.analyzer/constants {:seen #{while try s-expr? sym-call? :else quantum.core.analyze.clojure.predicates/s-expr? doseq :ns :name quantum.core.analyze.clojure.predicates/sym-call? :variadic let :file :end-column fn do when return defn if quantum.core.analyze.clojure.predicates :column :line :macro :end-line cond for :tag :fixed str :arglists case :doc :test throw}, :order [:tag :variadic :fixed :else str quantum.core.analyze.clojure.predicates/sym-call? :ns :name :file :end-column :column :line :end-line :arglists :doc :test quantum.core.analyze.clojure.predicates sym-call? :macro quantum.core.analyze.clojure.predicates/s-expr? s-expr? return defn fn while doseq do when for let if cond throw case try]}, :doc "Clojure (and variants) code analysis namespace.\n            Required for quantum.core.macros."}