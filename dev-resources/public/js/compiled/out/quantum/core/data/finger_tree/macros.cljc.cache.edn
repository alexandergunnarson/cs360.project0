;; Analyzed by ClojureScript 1.7.170
{:name quantum.core.data.finger-tree.macros, :doc "Persistent collections based on 2-3 finger trees.", :excludes #{defonce}, :use-macros {def- quantum.core.ns, whenf*n quantum.core.logic, doto->> quantum.core.function, condfc quantum.core.logic, f*n quantum.core.function, coll-and quantum.core.logic, resolve-local quantum.core.macros.core, if-cljs quantum.core.macros.core, fn-not quantum.core.logic, defcurried quantum.core.function, ifn quantum.core.logic, defalias quantum.core.ns, whencf*n quantum.core.logic, with-do quantum.core.function, <- quantum.core.function, whenc quantum.core.logic, ifp quantum.core.logic, fn-or quantum.core.logic, if*n quantum.core.logic, fn-eq? quantum.core.logic, condf*n quantum.core.logic, ns-exclude quantum.core.ns, coll-or quantum.core.logic, fn-and quantum.core.logic, defonce quantum.core.ns, fn-> quantum.core.function, rfn quantum.core.function, source quantum.core.ns, condpc quantum.core.logic, fn= quantum.core.logic, whenp quantum.core.logic, whenf quantum.core.logic, eq? quantum.core.logic, condf quantum.core.logic, fn->> quantum.core.function}, :require-macros {fn quantum.core.function, quantum.core.function quantum.core.function, cmacros quantum.core.macros.core, quantum.core.macros.core quantum.core.macros.core, logic quantum.core.logic, quantum.core.logic quantum.core.logic, ns quantum.core.ns, quantum.core.ns quantum.core.ns}, :uses {AMap quantum.core.ns, ILookup cljs.core, juxtm quantum.core.function, juxt-kv quantum.core.function, any? quantum.core.logic, AArrList quantum.core.ns, ?Counted quantum.core.macros.protocol, firsta quantum.core.function, IIndexed cljs.core, *fn quantum.core.function, ?Collection quantum.core.macros.protocol, ABool quantum.core.ns, IMeta cljs.core, ATreeMap quantum.core.ns, js-println quantum.core.ns, INext cljs.core, ICounted cljs.core, IStack cljs.core, IReversible cljs.core, IllegalArgumentException quantum.core.ns, IHash cljs.core, ASet quantum.core.ns, IEquiv cljs.core, with-pr->> quantum.core.function, nnil? quantum.core.logic, ALSeq quantum.core.ns, ?Seq quantum.core.macros.protocol, ARegex quantum.core.ns, with->> quantum.core.function, call quantum.core.function, AExactNum quantum.core.ns, IEmptyableCollection cljs.core, AEditable quantum.core.ns, ISet cljs.core, zeroid quantum.core.function, AKey quantum.core.ns, pfn quantum.core.macros.protocol, splice-or quantum.core.logic, with-msg->> quantum.core.function, ?Indexed quantum.core.macros.protocol, ?Stack quantum.core.macros.protocol, ?Sequential quantum.core.macros.protocol, ISeq cljs.core, compr quantum.core.function, AQueue quantum.core.ns, IAssociative cljs.core, ISeqable cljs.core, AError quantum.core.ns, fn-nil quantum.core.function, ISequential cljs.core, ADouble quantum.core.ns, withfs quantum.core.function, AVec quantum.core.ns, IWithMeta cljs.core, ADecimal quantum.core.ns, ICollection cljs.core, Exception quantum.core.ns, AInt quantum.core.ns, monoid quantum.core.function, ATransient quantum.core.ns, withf quantum.core.function, nempty? quantum.core.logic, ISorted cljs.core, ?Seqable quantum.core.macros.protocol, ANum quantum.core.ns, ANil quantum.core.ns, unary quantum.core.function, withf->> quantum.core.function}, :requires {clojure.core.rrb-vector clojure.core.rrb-vector, logic quantum.core.logic, quantum.core.macros.core quantum.core.macros.core, cmacros quantum.core.macros.core, cljs.core cljs.core, fn quantum.core.function, ns quantum.core.ns, quantum.core.logic quantum.core.logic, quantum.core.macros.protocol quantum.core.macros.protocol, quantum.core.ns quantum.core.ns, core cljs.core, quantum.core.function quantum.core.function}, :imports nil}