;; Analyzed by ClojureScript 1.7.170
{:use-macros {def- quantum.core.ns, with-resources quantum.core.resources, whenf*n quantum.core.logic, wait-until quantum.core.thread.async, doto->> quantum.core.function, try-times quantum.core.error, condfc quantum.core.logic, f*n quantum.core.function, coll-and quantum.core.logic, go cljs.core.async.macros, try+ quantum.core.error, fn-not quantum.core.logic, defcurried quantum.core.function, ifn quantum.core.logic, defalias quantum.core.ns, whencf*n quantum.core.logic, with-do quantum.core.function, <- quantum.core.function, whenc quantum.core.logic, go-loop cljs.core.async.macros, throw-when quantum.core.error, ifp quantum.core.logic, assertf-> quantum.core.error, fn-or quantum.core.logic, if*n quantum.core.logic, fn-eq? quantum.core.logic, condf*n quantum.core.logic, ns-exclude quantum.core.ns, coll-or quantum.core.logic, assertf->> quantum.core.error, fn-and quantum.core.logic, defonce quantum.core.ns, fn-> quantum.core.function, rfn quantum.core.function, throw+ quantum.core.error, source quantum.core.ns, condpc quantum.core.logic, fn= quantum.core.logic, assert quantum.core.error, throw-unless quantum.core.error, whenp quantum.core.logic, whenf quantum.core.logic, eq? quantum.core.logic, with-assert quantum.core.error, condf quantum.core.logic, fn->> quantum.core.function}, :excludes #{defonce assert}, :name quantum.core.thread, :imports nil, :requires {res quantum.core.resources, core-async cljs.core.async, clojure.core.rrb-vector clojure.core.rrb-vector, logic quantum.core.logic, log quantum.core.log, async quantum.core.thread.async, cljs.core cljs.core, fn quantum.core.function, vec quantum.core.data.vector, quantum.core.log quantum.core.log, cljs.core.async cljs.core.async, quantum.core.resources quantum.core.resources, ns quantum.core.ns, quantum.core.data.vector quantum.core.data.vector, quantum.core.logic quantum.core.logic, err quantum.core.error, quantum.core.thread.async quantum.core.thread.async, quantum.core.error quantum.core.error, quantum.core.collections.base quantum.core.collections.base, quantum.core.ns quantum.core.ns, core cljs.core, quantum.core.function quantum.core.function}, :uses {AMap quantum.core.ns, take!! quantum.core.thread.async, dissoc-in quantum.core.collections.base, juxtm quantum.core.function, vector+? quantum.core.data.vector, concur quantum.core.thread.async, juxt-kv quantum.core.function, <! cljs.core.async, any? quantum.core.logic, AArrList quantum.core.ns, firsta quantum.core.function, *fn quantum.core.function, Err quantum.core.error, ABool quantum.core.ns, ATreeMap quantum.core.ns, chan quantum.core.thread.async, js-println quantum.core.ns, IllegalArgumentException quantum.core.ns, >!! quantum.core.thread.async, catvec quantum.core.data.vector, ASet quantum.core.ns, with-pr->> quantum.core.function, nnil? quantum.core.logic, ALSeq quantum.core.ns, ARegex quantum.core.ns, with->> quantum.core.function, call quantum.core.function, AExactNum quantum.core.ns, put!! quantum.core.thread.async, subvec+ quantum.core.data.vector, AEditable quantum.core.ns, zeroid quantum.core.function, AKey quantum.core.ns, splice-or quantum.core.logic, vector+ quantum.core.data.vector, with-msg->> quantum.core.function, <!! quantum.core.thread.async, compr quantum.core.function, AQueue quantum.core.ns, peek!! quantum.core.thread.async, AError quantum.core.ns, fn-nil quantum.core.function, ADouble quantum.core.ns, withfs quantum.core.function, >! cljs.core.async, AVec quantum.core.ns, ->ex quantum.core.error, ADecimal quantum.core.ns, alts! cljs.core.async, Exception quantum.core.ns, empty! quantum.core.thread.async, AInt quantum.core.ns, monoid quantum.core.function, ATransient quantum.core.ns, withf quantum.core.function, alts!! quantum.core.thread.async, nempty? quantum.core.logic, ANum quantum.core.ns, ANil quantum.core.ns, unary quantum.core.function, withf->> quantum.core.function, with-cleanup quantum.core.resources}, :defs {reg {:name quantum.core.thread/reg, :file "src/cljc/quantum/core/thread.cljc", :line 17, :column 1, :end-line 17, :end-column 39, :doc "Thread registry", :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/thread.cljc", :line 17, :column 36, :end-line 17, :end-column 39, :doc "Thread registry"}}, ids {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/thread.cljc", :line 19, :column 7, :end-line 19, :end-column 10, :arglists (quote ([]))}, :name quantum.core.thread/ids, :variadic false, :file "src/cljc/quantum/core/thread.cljc", :end-column 10, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 19, :end-line 19, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, reg-tree {:name quantum.core.thread/reg-tree, :file "src/cljc/quantum/core/thread.cljc", :line 21, :column 1, :end-line 21, :end-column 18, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/thread.cljc", :line 21, :column 10, :end-line 21, :end-column 18}}, gen-proc-id {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/thread.cljc", :line 277, :column 7, :end-line 277, :end-column 18, :arglists (quote ([id parent name-]))}, :name quantum.core.thread/gen-proc-id, :variadic false, :file "src/cljc/quantum/core/thread.cljc", :end-column 18, :method-params ([id parent name-]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 277, :end-line 277, :max-fixed-arity 3, :fn-var true, :arglists (quote ([id parent name-]))}, Distributor {:num-fields 9, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :name quantum.core.thread/Distributor, :file "src/cljc/quantum/core/thread.cljc", :end-column 23, :type true, :column 12, :internal-ctor true, :line 740, :record true, :end-line 740, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}}, ->Distributor {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/thread.cljc", :line 740, :column 12, :end-line 740, :end-column 23, :internal-ctor true, :factory :positional, :arglists (quote ([name work-queue cache max-threads thread-registrar threadpool distributor-fn interrupted? log]))}, :name quantum.core.thread/->Distributor, :variadic false, :file "src/cljc/quantum/core/thread.cljc", :end-column 23, :method-params ([name work-queue cache max-threads thread-registrar threadpool distributor-fn interrupted? log]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 740, :end-line 740, :max-fixed-arity 9, :fn-var true, :arglists (quote ([name work-queue cache max-threads thread-registrar threadpool distributor-fn interrupted? log]))}, map->Distributor {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/thread.cljc", :line 740, :column 12, :end-line 740, :end-column 23, :internal-ctor true, :factory :map, :arglists (quote ([G__44156]))}, :name quantum.core.thread/map->Distributor, :variadic false, :file "src/cljc/quantum/core/thread.cljc", :end-column 23, :method-params ([G__44156]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 740, :end-line 740, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__44156]))}}, :require-macros {res quantum.core.resources, logic quantum.core.logic, cljs.core.async.macros cljs.core.async.macros, log quantum.core.log, async quantum.core.thread.async, fn quantum.core.function, quantum.core.log quantum.core.log, quantum.core.resources quantum.core.resources, ns quantum.core.ns, quantum.core.logic quantum.core.logic, err quantum.core.error, asyncm cljs.core.async.macros, quantum.core.thread.async quantum.core.thread.async, quantum.core.error quantum.core.error, quantum.core.ns quantum.core.ns, quantum.core.function quantum.core.function}, :cljs.analyzer/constants {:seen #{max-threads log :interrupted? :else :thread-registrar :name interrupted? thread-registrar name :work-queue :cache :distributor-fn :threadpool work-queue cache :max-threads distributor-fn :log threadpool}, :order [:else :name :work-queue :cache :max-threads :thread-registrar :threadpool :distributor-fn :interrupted? :log name work-queue cache max-threads thread-registrar threadpool distributor-fn interrupted? log]}, :doc "Complex thread management made simple.\n          Aliases core.async for convenience."}