;; Analyzed by ClojureScript 1.7.170
{:use-macros {def- quantum.core.ns, whenf*n quantum.core.logic, doto->> quantum.core.function, try-times quantum.core.error, condfc quantum.core.logic, f*n quantum.core.function, coll-and quantum.core.logic, try+ quantum.core.error, fn-not quantum.core.logic, defcurried quantum.core.function, ifn quantum.core.logic, defalias quantum.core.ns, whencf*n quantum.core.logic, with-do quantum.core.function, <- quantum.core.function, whenc quantum.core.logic, throw-when quantum.core.error, ifp quantum.core.logic, assertf-> quantum.core.error, fn-or quantum.core.logic, if*n quantum.core.logic, fn-eq? quantum.core.logic, condf*n quantum.core.logic, ns-exclude quantum.core.ns, coll-or quantum.core.logic, assertf->> quantum.core.error, pr-attrs quantum.core.print, fn-and quantum.core.logic, defonce quantum.core.ns, fn-> quantum.core.function, rfn quantum.core.function, throw+ quantum.core.error, source quantum.core.ns, condpc quantum.core.logic, fn= quantum.core.logic, assert quantum.core.error, throw-unless quantum.core.error, whenp quantum.core.logic, whenf quantum.core.logic, eq? quantum.core.logic, with-assert quantum.core.error, condf quantum.core.logic, fn->> quantum.core.function}, :excludes #{defonce assert merge sorted-map-by sorted-map}, :name quantum.core.type.core, :imports nil, :requires {set quantum.core.data.set, clojure.core.rrb-vector clojure.core.rrb-vector, logic quantum.core.logic, pr quantum.core.print, log quantum.core.log, map quantum.core.data.map, cljs.core cljs.core, fn quantum.core.function, fast-zip.core fast-zip.core, quantum.core.log quantum.core.log, ns quantum.core.ns, quantum.core.logic quantum.core.logic, boot quantum.core.type.bootstrap, cbase quantum.core.collections.base, err quantum.core.error, quantum.core.data.set quantum.core.data.set, quantum.core.print quantum.core.print, quantum.core.type.bootstrap quantum.core.type.bootstrap, zip fast-zip.core, quantum.core.error quantum.core.error, quantum.core.collections.base quantum.core.collections.base, quantum.core.ns quantum.core.ns, quantum.core.data.map quantum.core.data.map, core cljs.core, quantum.core.function quantum.core.function}, :uses {AMap quantum.core.ns, sorted-set+ quantum.core.data.set, juxtm quantum.core.function, ! quantum.core.print, juxt-kv quantum.core.function, any? quantum.core.logic, AArrList quantum.core.ns, firsta quantum.core.function, *fn quantum.core.function, Err quantum.core.error, ABool quantum.core.ns, ATreeMap quantum.core.ns, js-println quantum.core.ns, IllegalArgumentException quantum.core.ns, ASet quantum.core.ns, with-pr->> quantum.core.function, nnil? quantum.core.logic, ALSeq quantum.core.ns, ARegex quantum.core.ns, with->> quantum.core.function, call quantum.core.function, AExactNum quantum.core.ns, AEditable quantum.core.ns, zeroid quantum.core.function, AKey quantum.core.ns, splice-or quantum.core.logic, !* quantum.core.print, with-msg->> quantum.core.function, compr quantum.core.function, AQueue quantum.core.ns, AError quantum.core.ns, fn-nil quantum.core.function, ADouble quantum.core.ns, withfs quantum.core.function, AVec quantum.core.ns, ->ex quantum.core.error, ADecimal quantum.core.ns, Exception quantum.core.ns, ordered-map quantum.core.data.map, AInt quantum.core.ns, monoid quantum.core.function, ATransient quantum.core.ns, withf quantum.core.function, nempty? quantum.core.logic, ANum quantum.core.ns, ANil quantum.core.ns, map-entry quantum.core.data.map, unary quantum.core.function, withf->> quantum.core.function}, :defs {class {:name quantum.core.type.core/class, :file "src/cljc/quantum/core/type/core.cljc", :line 11, :column 10, :end-line 11, :end-column 20, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/type/core.cljc", :line 11, :column 15, :end-line 11, :end-column 20}}, types-unevaled {:name quantum.core.type.core/types-unevaled, :meta {:file nil}, :file "src/cljc/quantum/core/type/core.cljc", :line 13, :column 1}, arr-types {:name quantum.core.type.core/arr-types, :meta {:file nil}, :file "src/cljc/quantum/core/type/core.cljc", :line 13, :column 1}, types {:name quantum.core.type.core/types, :meta {:file nil}, :file "src/cljc/quantum/core/type/core.cljc", :line 13, :column 1}, primitive-types {:name quantum.core.type.core/primitive-types, :meta {:file nil}, :file "src/cljc/quantum/core/type/core.cljc", :line 13, :column 1}, name-from-class {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/type/core.cljc", :line 15, :column 7, :end-line 15, :end-column 22, :arglists (quote ([class-0]))}, :name quantum.core.type.core/name-from-class, :variadic false, :file "src/cljc/quantum/core/type/core.cljc", :end-column 22, :method-params ([class-0]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 15, :end-line 15, :max-fixed-arity 1, :fn-var true, :arglists (quote ([class-0]))}, compiler-lang {:name quantum.core.type.core/compiler-lang, :file "src/cljc/quantum/core/type/core.cljc", :line 47, :column 1, :end-line 47, :end-column 19, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/type/core.cljc", :line 47, :column 6, :end-line 47, :end-column 19}}, default-types {:name quantum.core.type.core/default-types, :file "src/cljc/quantum/core/type/core.cljc", :line 48, :column 1, :end-line 48, :end-column 19, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/type/core.cljc", :line 48, :column 6, :end-line 48, :end-column 19}}, type-casts-map {:name quantum.core.type.core/type-casts-map, :file "src/cljc/quantum/core/type/core.cljc", :line 54, :column 1, :end-line 54, :end-column 20, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/core/type/core.cljc", :line 54, :column 6, :end-line 54, :end-column 20}}}, :require-macros {logic quantum.core.logic, pr quantum.core.print, log quantum.core.log, fn quantum.core.function, quantum.core.log quantum.core.log, ns quantum.core.ns, quantum.core.logic quantum.core.logic, boot quantum.core.type.bootstrap, err quantum.core.error, quantum.core.print quantum.core.print, quantum.core.type.bootstrap quantum.core.type.bootstrap, quantum.core.error quantum.core.error, quantum.core.ns quantum.core.ns, quantum.core.function quantum.core.function}, :cljs.analyzer/constants {:seen #{decimal? java.lang.Short clojure.lang.APersistentVector$RSeq clojure.lang.MultiFn java.util.Arrays$ArrayList seq? cljs.core/PersistentHashMap integral? booleans? clojure.lang.PersistentList clojure.lang.PersistentVector$ChunkedSeq Object java.lang.Integer clojure.lang.Tuple$T3 short-array java.util.ArrayList fn? cljs.core.ArrayList js/RegExp [J java.io.File byte-array? clojure.lang.APersistentVector vector? java.math.BigInteger boolean cljs.core/TransientVector bigint? object primitive? cljs.core/PersistentArrayMap clojure.lang.PersistentQueue boolean? clojure.lang.PersistentHashMap$TransientHashMap atom? tree-map? char? sorted-map? clojure.lang.PersistentTreeMap char String shorts? boolean-array? clojure.lang.PersistentArrayMap cljs.core/IndexedSeq clojure.lang.PersistentList$EmptyList clojure.lang.APersistentMap$KeySeq clojure.lang.Tuple$T2 boolean-array java.util.regex.Pattern clojure.lang.PersistentArrayMap$TransientArrayMap multimethod? cljs.core/Keyword bool? cdlist? float? int-array set? cljs.core/EmptyList clojure.lang.APersistentSet cljs.core/Delay clojure.lang.Cons [C clojure.lang.PersistentHashSet map? chars? java.lang.Character long double short-array? [I java.lang.Double cljs.core/ValSeq listy? short short? string? array-map? :msg cons? double? cljs.core/TransientHashMap int map-entry? [F number java.lang.Boolean int? associative? clojure.lang.Tuple$T5 clojure.lang.Tuple$T1 keyword? char-array? [Ljava.lang.Object; transient? double-array regex? vec? bigint java.lang.Float float pinteger? pattern? default clojure.lang.Fn indexed? cljs.core/PersistentVector array-list? cljs.core/List byte-array java.lang.Long clojure.lang.ITransientCollection editable? clojure.lang.IPersistentSet cljs.core.Cons nil? doubles? cljs.core/TransientArrayMap clojure.lang.IAtom bytes? record? double-array? queue? clojure.lang.PersistentHashMap byte? array int-array? string cljs.core/TransientHashSet cljs.core.PersistentTreeMap cljs.core/PersistentHashSet cljs.core.Symbol function long-array objects? integer? clojure.data.finger_tree.CountedDoubleList file? object-array java.lang.Byte flatland.ordered.map.OrderedMap clojure.lang.LazySeq [Z cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core.LazySeq clojure.core.protocols.CollReduce clojure.lang.APersistentMap$ValSeq java.lang.Number float-array cljs.core/Atom long? inc cljs.core/PersistentTreeSet cljs.core.PersistentQueue quote floats? [B class bigdec clojure.lang.IndexedSeq list? array? float-array? clojure.lang.PersistentVector clojure.lang.MapEntry byte [D clojure.lang.BigInt clojure.lang.IEditableCollection java.math.BigDecimal clojure.lang.Delay qreducer? clj->js cljs.core.IRecord clojure.lang.Tuple$T4 :clj :cljs long-array? clojure.lang.Keyword lseq? char-array dlist? clojure.lang.Tuple$T6 longs? ints? clojure.lang.Tuple$T0 number? clojure.lang.Symbol transientizable? :any symbol? clojure.lang.IRecord clojure.core.rrb_vector.rrbt.Vector [S num? coll? object-array?}, :order [:clj :cljs decimal? seq? integral? booleans? fn? byte-array? vector? bigint? primitive? boolean? atom? tree-map? char? sorted-map? shorts? boolean-array? multimethod? bool? cdlist? float? set? map? chars? short-array? listy? short? string? array-map? cons? double? map-entry? int? associative? keyword? char-array? transient? regex? vec? pinteger? pattern? indexed? array-list? editable? nil? doubles? bytes? record? double-array? queue? byte? int-array? objects? integer? file? long? floats? list? array? float-array? qreducer? long-array? lseq? dlist? longs? ints? number? transientizable? :any symbol? num? coll? object-array? double java.lang.Double java.lang.Float float java.math.BigDecimal clojure.lang.PersistentList clojure.lang.PersistentVector$ChunkedSeq clojure.lang.PersistentQueue clojure.lang.PersistentList$EmptyList clojure.lang.APersistentMap$KeySeq clojure.lang.Cons clojure.data.finger_tree.CountedDoubleList clojure.lang.LazySeq clojure.lang.APersistentMap$ValSeq clojure.lang.IndexedSeq java.lang.Short java.lang.Integer java.math.BigInteger boolean char java.lang.Character long short int java.lang.Boolean java.lang.Long java.lang.Number clojure.lang.BigInt [Z clojure.lang.Fn [B clojure.lang.APersistentVector$RSeq clojure.lang.Tuple$T3 clojure.lang.APersistentVector clojure.lang.Tuple$T2 clojure.lang.Tuple$T5 clojure.lang.Tuple$T1 clojure.lang.PersistentVector clojure.lang.Tuple$T4 clojure.lang.Tuple$T6 clojure.lang.Tuple$T0 clojure.core.rrb_vector.rrbt.Vector byte clojure.lang.IAtom clojure.lang.PersistentTreeMap [S clojure.lang.MultiFn clojure.lang.APersistentSet clojure.lang.IPersistentSet clojure.lang.PersistentHashMap$TransientHashMap clojure.lang.PersistentArrayMap clojure.lang.PersistentArrayMap$TransientArrayMap clojure.lang.PersistentHashMap flatland.ordered.map.OrderedMap [C String clojure.lang.MapEntry clojure.lang.Keyword clojure.lang.ITransientCollection java.util.regex.Pattern java.util.Arrays$ArrayList java.util.ArrayList clojure.lang.IEditableCollection [D clojure.lang.IRecord java.lang.Byte [I [Ljava.lang.Object; java.io.File [F [J clojure.core.protocols.CollReduce clojure.lang.Delay clojure.lang.PersistentHashSet Object clojure.lang.Symbol cljs.core/IndexedSeq cljs.core/EmptyList cljs.core/ValSeq cljs.core/List cljs.core.Cons cljs.core/KeySeq cljs.core/ChunkedSeq cljs.core.LazySeq cljs.core.PersistentQueue number function cljs.core/TransientVector cljs.core/PersistentVector string cljs.core/Atom cljs.core.PersistentTreeMap cljs.core/TransientHashSet cljs.core/PersistentHashSet cljs.core/PersistentTreeSet cljs.core/PersistentHashMap cljs.core/PersistentArrayMap cljs.core/TransientHashMap cljs.core/TransientArrayMap cljs.core/Keyword js/RegExp cljs.core.ArrayList cljs.core.IRecord array cljs.core/Delay default cljs.core.Symbol class inc quote double-array long-array short-array int-array char-array float-array byte-array boolean-array object-array clj->js object :msg bigdec bigint]}, :doc "Some useful macros, like de-repetitivizing protocol extensions.\n          Also some plumbing macros for |for| loops and the like."}