;; Analyzed by ClojureScript 1.7.170
{:use-macros {def- quantum.core.ns, whenf*n quantum.core.logic, wait-until quantum.core.thread.async, doto->> quantum.core.function, try-times quantum.core.error, condfc quantum.core.logic, f*n quantum.core.function, coll-and quantum.core.logic, go cljs.core.async.macros, try+ quantum.core.error, fn-not quantum.core.logic, defcurried quantum.core.function, ifn quantum.core.logic, defalias quantum.core.ns, whencf*n quantum.core.logic, with-do quantum.core.function, <- quantum.core.function, whenc quantum.core.logic, go-loop cljs.core.async.macros, throw-when quantum.core.error, <? datomic-cljs.macros, ifp quantum.core.logic, assertf-> quantum.core.error, fn-or quantum.core.logic, if*n quantum.core.logic, fn-eq? quantum.core.logic, condf*n quantum.core.logic, ns-exclude quantum.core.ns, kmap quantum.core.collections.base, coll-or quantum.core.logic, assertf->> quantum.core.error, pr-attrs quantum.core.print, fn-and quantum.core.logic, defonce quantum.core.ns, fn-> quantum.core.function, rfn quantum.core.function, throw+ quantum.core.error, source quantum.core.ns, condpc quantum.core.logic, fn= quantum.core.logic, assert quantum.core.error, throw-unless quantum.core.error, whenp quantum.core.logic, whenf quantum.core.logic, eq? quantum.core.logic, with-assert quantum.core.error, condf quantum.core.logic, fn->> quantum.core.function}, :excludes #{defonce assert seqable?}, :name quantum.db.datomic, :imports nil, :requires {quantum.core.collections quantum.core.collections, res quantum.core.resources, uuid cljs-uuid-utils.core, core-async cljs.core.async, clojure.core.rrb-vector clojure.core.rrb-vector, logic quantum.core.logic, pr quantum.core.print, log quantum.core.log, tpred quantum.core.type.predicates, cljs-uuid-utils.core cljs-uuid-utils.core, async quantum.core.thread.async, cljs.core cljs.core, fn quantum.core.function, fast-zip.core fast-zip.core, quantum.core.log quantum.core.log, cljs.core.async cljs.core.async, quantum.core.resources quantum.core.resources, datascript.core datascript.core, db quantum.db.datomic.core, mdb datascript.core, ns quantum.core.ns, quantum.core.logic quantum.core.logic, cbase quantum.core.collections.base, err quantum.core.error, com.stuartsierra.component com.stuartsierra.component, coll quantum.core.collections, rx-db quantum.db.datomic.reactive.core, component com.stuartsierra.component, quantum.core.print quantum.core.print, datomic-cljs.api datomic-cljs.api, c cljs.core, quantum.db.datomic.reactive.core quantum.db.datomic.reactive.core, quantum.core.thread.async quantum.core.thread.async, zip fast-zip.core, bdb datomic-cljs.api, quantum.core.error quantum.core.error, quantum.db.datomic.core quantum.db.datomic.core, quantum.core.collections.base quantum.core.collections.base, quantum.core.ns quantum.core.ns, core cljs.core, quantum.core.function quantum.core.function, quantum.core.type.predicates quantum.core.type.predicates}, :uses {AMap quantum.core.ns, take!! quantum.core.thread.async, juxtm quantum.core.function, concur quantum.core.thread.async, ! quantum.core.print, juxt-kv quantum.core.function, <! cljs.core.async, any? quantum.core.logic, AArrList quantum.core.ns, boolean? quantum.core.type.predicates, atom? quantum.core.type.predicates, firsta quantum.core.function, *fn quantum.core.function, Err quantum.core.error, ABool quantum.core.ns, ATreeMap quantum.core.ns, chan quantum.core.thread.async, js-println quantum.core.ns, IllegalArgumentException quantum.core.ns, >!! quantum.core.thread.async, ASet quantum.core.ns, with-pr->> quantum.core.function, nnil? quantum.core.logic, ALSeq quantum.core.ns, ARegex quantum.core.ns, with->> quantum.core.function, call quantum.core.function, AExactNum quantum.core.ns, put!! quantum.core.thread.async, AEditable quantum.core.ns, zeroid quantum.core.function, AKey quantum.core.ns, splice-or quantum.core.logic, !* quantum.core.print, with-msg->> quantum.core.function, <!! quantum.core.thread.async, compr quantum.core.function, AQueue quantum.core.ns, peek!! quantum.core.thread.async, AError quantum.core.ns, fn-nil quantum.core.function, ADouble quantum.core.ns, withfs quantum.core.function, >! cljs.core.async, AVec quantum.core.ns, derefable? quantum.core.type.predicates, ->ex quantum.core.error, ADecimal quantum.core.ns, alts! cljs.core.async, Exception quantum.core.ns, empty! quantum.core.thread.async, AInt quantum.core.ns, monoid quantum.core.function, ATransient quantum.core.ns, withf quantum.core.function, alts!! quantum.core.thread.async, nempty? quantum.core.logic, ANum quantum.core.ns, ANil quantum.core.ns, unary quantum.core.function, seqable? quantum.core.type.predicates, withf->> quantum.core.function}, :defs {rx-q {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :line 31, :column 7, :end-line 31, :end-column 11, :arglists (quote ([query] [query conn & args])), :doc "Reactive |q|. Must be called within a Reagent component and will only\n   update the component whenever the data it is querying has changed.", :todo ["Add Clojure support"], :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([query]), :arglists ([query] [query conn & args]), :arglists-meta (nil nil)}}, :name quantum.db.datomic/rx-q, :variadic true, :file "src/cljc/quantum/db/datomic.cljc", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 2, :method-params ([query]), :arglists ([query] [query conn & args]), :arglists-meta (nil nil)}, :method-params ([query]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 31, :todo ["Add Clojure support"], :end-line 31, :max-fixed-arity 2, :fn-var true, :arglists ([query] [query conn & args]), :doc "Reactive |q|. Must be called within a Reagent component and will only\n   update the component whenever the data it is querying has changed."}, ->db {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :line 233, :column 7, :end-line 233, :end-column 11, :arglists (quote ([{{:keys [type name host port rest-port txr-alias create-if-not-present?], :as backend} :backend, {:keys [], :as reconciler} :reconciler, {:keys [history-limit], :as ephemeral} :ephemeral, :as config}])), :doc "Constructor for |Database|."}, :name quantum.db.datomic/->db, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 11, :method-params ([p__47338]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 233, :end-line 233, :max-fixed-arity 1, :fn-var true, :arglists (quote ([{{:keys [type name host port rest-port txr-alias create-if-not-present?], :as backend} :backend, {:keys [], :as reconciler} :reconciler, {:keys [history-limit], :as ephemeral} :ephemeral, :as config}])), :doc "Constructor for |Database|."}, map->Database {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :line 212, :column 3, :end-line 212, :end-column 11, :doc "Database-system consisting of an EphemeralDatabase (e.g. DataScript),\n          BackendDatabase (e.g. Datomic), and a reconciler which constantly\n          pushes diffs from the EphemeralDatabase to the BackendDatabase\n          and pulls new data from the BackendDatabase.\n\n          A Datomic subscription model would be really nice for performance\n          (ostensibly) to avoid the constant backend polling of the reconciler,\n          but unfortunately Datomic does not have this.\n\n          @backend\n            Can be one of three things:\n              1) A direct connection to a Datomic database using the Datomic Peer API\n                 - This option is for Clojure (e.g. server) only, not ClojureScript\n              2) A direct connection to a Datomic database using the Datomic HTTP API\n                 - This option is currently not proven to be secure and is awaiting\n                   further developments by the Cognitect team.\n              3) A REST endpoint pair:\n                 - One for pushing, e.g. 'POST /db'\n                 - One for pulling, e.g. 'GET  /db'\n                 - This way the Datomic database is not directly exposed to the client,\n                   but rather the server is able to use access control and other\n                   security measures when handling queries from the client.\n                   This is the (currently) recommended option.\n          @reconciler\n            is", :internal-ctor true, :factory :map, :arglists (quote ([G__47332]))}, :name quantum.db.datomic/map->Database, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 11, :method-params ([G__47332]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 186, :end-line 212, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__47332])), :doc "Database-system consisting of an EphemeralDatabase (e.g. DataScript),\n          BackendDatabase (e.g. Datomic), and a reconciler which constantly\n          pushes diffs from the EphemeralDatabase to the BackendDatabase\n          and pulls new data from the BackendDatabase.\n\n          A Datomic subscription model would be really nice for performance\n          (ostensibly) to avoid the constant backend polling of the reconciler,\n          but unfortunately Datomic does not have this.\n\n          @backend\n            Can be one of three things:\n              1) A direct connection to a Datomic database using the Datomic Peer API\n                 - This option is for Clojure (e.g. server) only, not ClojureScript\n              2) A direct connection to a Datomic database using the Datomic HTTP API\n                 - This option is currently not proven to be secure and is awaiting\n                   further developments by the Cognitect team.\n              3) A REST endpoint pair:\n                 - One for pushing, e.g. 'POST /db'\n                 - One for pulling, e.g. 'GET  /db'\n                 - This way the Datomic database is not directly exposed to the client,\n                   but rather the server is able to use access control and other\n                   security measures when handling queries from the client.\n                   This is the (currently) recommended option.\n          @reconciler\n            is"}, ->Database {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :line 212, :column 3, :end-line 212, :end-column 11, :doc "Database-system consisting of an EphemeralDatabase (e.g. DataScript),\n          BackendDatabase (e.g. Datomic), and a reconciler which constantly\n          pushes diffs from the EphemeralDatabase to the BackendDatabase\n          and pulls new data from the BackendDatabase.\n\n          A Datomic subscription model would be really nice for performance\n          (ostensibly) to avoid the constant backend polling of the reconciler,\n          but unfortunately Datomic does not have this.\n\n          @backend\n            Can be one of three things:\n              1) A direct connection to a Datomic database using the Datomic Peer API\n                 - This option is for Clojure (e.g. server) only, not ClojureScript\n              2) A direct connection to a Datomic database using the Datomic HTTP API\n                 - This option is currently not proven to be secure and is awaiting\n                   further developments by the Cognitect team.\n              3) A REST endpoint pair:\n                 - One for pushing, e.g. 'POST /db'\n                 - One for pulling, e.g. 'GET  /db'\n                 - This way the Datomic database is not directly exposed to the client,\n                   but rather the server is able to use access control and other\n                   security measures when handling queries from the client.\n                   This is the (currently) recommended option.\n          @reconciler\n            is", :internal-ctor true, :factory :positional, :arglists (quote ([ephemeral reconciler backend]))}, :name quantum.db.datomic/->Database, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 11, :method-params ([ephemeral reconciler backend]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 186, :end-line 212, :max-fixed-arity 3, :fn-var true, :arglists (quote ([ephemeral reconciler backend])), :doc "Database-system consisting of an EphemeralDatabase (e.g. DataScript),\n          BackendDatabase (e.g. Datomic), and a reconciler which constantly\n          pushes diffs from the EphemeralDatabase to the BackendDatabase\n          and pulls new data from the BackendDatabase.\n\n          A Datomic subscription model would be really nice for performance\n          (ostensibly) to avoid the constant backend polling of the reconciler,\n          but unfortunately Datomic does not have this.\n\n          @backend\n            Can be one of three things:\n              1) A direct connection to a Datomic database using the Datomic Peer API\n                 - This option is for Clojure (e.g. server) only, not ClojureScript\n              2) A direct connection to a Datomic database using the Datomic HTTP API\n                 - This option is currently not proven to be secure and is awaiting\n                   further developments by the Cognitect team.\n              3) A REST endpoint pair:\n                 - One for pushing, e.g. 'POST /db'\n                 - One for pulling, e.g. 'GET  /db'\n                 - This way the Datomic database is not directly exposed to the client,\n                   but rather the server is able to use access control and other\n                   security measures when handling queries from the client.\n                   This is the (currently) recommended option.\n          @reconciler\n            is"}, rx-transact! {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :line 45, :column 7, :end-line 45, :end-column 19, :arglists (quote ([tx-data] [conn tx-data])), :doc "Buffers its transactions in 1/60 second intervals, passes them through\n   any handlers set up in |rx-db/before-tx!|, then batch transacts them to the database.", :todo ["Add (better) Clojure support"], :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tx-data] [conn tx-data]), :arglists ([tx-data] [conn tx-data]), :arglists-meta (nil nil)}}, :name quantum.db.datomic/rx-transact!, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([tx-data] [conn tx-data]), :arglists ([tx-data] [conn tx-data]), :arglists-meta (nil nil)}, :method-params ([tx-data] [conn tx-data]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 45, :todo ["Add (better) Clojure support"], :end-line 45, :max-fixed-arity 2, :fn-var true, :arglists ([tx-data] [conn tx-data]), :doc "Buffers its transactions in 1/60 second intervals, passes them through\n   any handlers set up in |rx-db/before-tx!|, then batch transacts them to the database."}, BackendDatabase {:num-fields 22, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative com.stuartsierra.component/Lifecycle cljs.core/IMap cljs.core/ILookup}, :name quantum.db.datomic/BackendDatabase, :file "src/cljc/quantum/db/datomic.cljc", :end-column 18, :type true, :column 3, :internal-ctor true, :line 94, :record true, :todo ["Decompose this"], :end-line 94, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Datomic database.\n\n          @start-txr? is a boolean which defines whether the transactor should be started.\n          @partitions is a seq (preferably set) of keywords identifying partitions"}, EphemeralDatabase {:num-fields 4, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative com.stuartsierra.component/Lifecycle cljs.core/IMap cljs.core/ILookup}, :name quantum.db.datomic/EphemeralDatabase, :file "src/cljc/quantum/db/datomic.cljc", :end-column 20, :type true, :column 3, :internal-ctor true, :line 60, :record true, :end-line 60, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Ephemeral (in-memory) database. Currently implemented as\n          DataScript database. Once the reference to @conn is lost,\n          the database is garbage-collected.\n\n          @conn, while also a 'connection', is really an atom with the current DataScript DB value."}, Database {:num-fields 3, :protocols #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IIterable cljs.core/IWithMeta cljs.core/IAssociative com.stuartsierra.component/Lifecycle cljs.core/IMap cljs.core/ILookup}, :name quantum.db.datomic/Database, :file "src/cljc/quantum/db/datomic.cljc", :end-column 11, :type true, :column 3, :internal-ctor true, :line 212, :record true, :end-line 212, :skip-protocol-flag #{cljs.core/IRecord cljs.core/IEquiv cljs.core/IHash cljs.core/ICollection cljs.core/ICounted cljs.core/ISeqable cljs.core/IMeta cljs.core/ICloneable cljs.core/IPrintWithWriter cljs.core/IWithMeta cljs.core/IAssociative cljs.core/IMap cljs.core/ILookup}, :doc "Database-system consisting of an EphemeralDatabase (e.g. DataScript),\n          BackendDatabase (e.g. Datomic), and a reconciler which constantly\n          pushes diffs from the EphemeralDatabase to the BackendDatabase\n          and pulls new data from the BackendDatabase.\n\n          A Datomic subscription model would be really nice for performance\n          (ostensibly) to avoid the constant backend polling of the reconciler,\n          but unfortunately Datomic does not have this.\n\n          @backend\n            Can be one of three things:\n              1) A direct connection to a Datomic database using the Datomic Peer API\n                 - This option is for Clojure (e.g. server) only, not ClojureScript\n              2) A direct connection to a Datomic database using the Datomic HTTP API\n                 - This option is currently not proven to be secure and is awaiting\n                   further developments by the Cognitect team.\n              3) A REST endpoint pair:\n                 - One for pushing, e.g. 'POST /db'\n                 - One for pulling, e.g. 'GET  /db'\n                 - This way the Datomic database is not directly exposed to the client,\n                   but rather the server is able to use access control and other\n                   security measures when handling queries from the client.\n                   This is the (currently) recommended option.\n          @reconciler\n            is"}, ->EphemeralDatabase {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :line 60, :column 3, :end-line 60, :end-column 20, :doc "Ephemeral (in-memory) database. Currently implemented as\n          DataScript database. Once the reference to @conn is lost,\n          the database is garbage-collected.\n\n          @conn, while also a 'connection', is really an atom with the current DataScript DB value.", :internal-ctor true, :factory :positional, :arglists (quote ([conn history history-limit reactive?]))}, :name quantum.db.datomic/->EphemeralDatabase, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 20, :method-params ([conn history history-limit reactive?]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 54, :end-line 60, :max-fixed-arity 4, :fn-var true, :arglists (quote ([conn history history-limit reactive?])), :doc "Ephemeral (in-memory) database. Currently implemented as\n          DataScript database. Once the reference to @conn is lost,\n          the database is garbage-collected.\n\n          @conn, while also a 'connection', is really an atom with the current DataScript DB value."}, map->EphemeralDatabase {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :line 60, :column 3, :end-line 60, :end-column 20, :doc "Ephemeral (in-memory) database. Currently implemented as\n          DataScript database. Once the reference to @conn is lost,\n          the database is garbage-collected.\n\n          @conn, while also a 'connection', is really an atom with the current DataScript DB value.", :internal-ctor true, :factory :map, :arglists (quote ([G__47274]))}, :name quantum.db.datomic/map->EphemeralDatabase, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 20, :method-params ([G__47274]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 54, :end-line 60, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__47274])), :doc "Ephemeral (in-memory) database. Currently implemented as\n          DataScript database. Once the reference to @conn is lost,\n          the database is garbage-collected.\n\n          @conn, while also a 'connection', is really an atom with the current DataScript DB value."}, map->BackendDatabase {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :end-column 18, :column 3, :internal-ctor true, :factory :map, :line 94, :todo ["Decompose this"], :end-line 94, :arglists (quote ([G__47284])), :doc "Datomic database.\n\n          @start-txr? is a boolean which defines whether the transactor should be started.\n          @partitions is a seq (preferably set) of keywords identifying partitions"}, :name quantum.db.datomic/map->BackendDatabase, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 18, :method-params ([G__47284]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :map, :line 88, :todo ["Decompose this"], :end-line 94, :max-fixed-arity 1, :fn-var true, :arglists (quote ([G__47284])), :doc "Datomic database.\n\n          @start-txr? is a boolean which defines whether the transactor should be started.\n          @partitions is a seq (preferably set) of keywords identifying partitions"}, ->BackendDatabase {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :end-column 18, :column 3, :internal-ctor true, :factory :positional, :line 94, :todo ["Decompose this"], :end-line 94, :arglists (quote ([type name db-name table-name instance-name host port rest-port uri conn create-if-not-present? start-txr? txr-bin-path txr-props-path txr-dir txr-process txr-alias init-partitions? partitions default-partition init-schemas? schemas])), :doc "Datomic database.\n\n          @start-txr? is a boolean which defines whether the transactor should be started.\n          @partitions is a seq (preferably set) of keywords identifying partitions"}, :name quantum.db.datomic/->BackendDatabase, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 18, :method-params ([type name db-name table-name instance-name host port rest-port uri conn create-if-not-present? start-txr? txr-bin-path txr-props-path txr-dir txr-process txr-alias init-partitions? partitions default-partition init-schemas? schemas]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :internal-ctor true, :factory :positional, :line 88, :todo ["Decompose this"], :end-line 94, :max-fixed-arity 22, :fn-var true, :arglists (quote ([type name db-name table-name instance-name host port rest-port uri conn create-if-not-present? start-txr? txr-bin-path txr-props-path txr-dir txr-process txr-alias init-partitions? partitions default-partition init-schemas? schemas])), :doc "Datomic database.\n\n          @start-txr? is a boolean which defines whether the transactor should be started.\n          @partitions is a seq (preferably set) of keywords identifying partitions"}, rx-pull {:protocol-inline nil, :meta {:file "/Users/alexandergunnarson/Development/Source Code Projects/byu/CS 360/Project0/src/cljc/quantum/db/datomic.cljc", :line 38, :column 7, :end-line 38, :end-column 14, :arglists (quote ([selector eid] [conn selector eid])), :doc "Reactive |pull|. Only attempts to pull any new data if there has been a\n   transaction of any datoms that might have changed the data it is looking at.", :todo ["Add Clojure support"], :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([selector eid] [conn selector eid]), :arglists ([selector eid] [conn selector eid]), :arglists-meta (nil nil)}}, :name quantum.db.datomic/rx-pull, :variadic false, :file "src/cljc/quantum/db/datomic.cljc", :end-column 14, :top-fn {:variadic false, :max-fixed-arity 3, :method-params ([selector eid] [conn selector eid]), :arglists ([selector eid] [conn selector eid]), :arglists-meta (nil nil)}, :method-params ([selector eid] [conn selector eid]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 38, :todo ["Add Clojure support"], :end-line 38, :max-fixed-arity 3, :fn-var true, :arglists ([selector eid] [conn selector eid]), :doc "Reactive |pull|. Only attempts to pull any new data if there has been a\n   transaction of any datoms that might have changed the data it is looking at."}}, :require-macros {logic quantum.core.logic, cljs.core.async.macros cljs.core.async.macros, pr quantum.core.print, log quantum.core.log, datomic-cljs.macros datomic-cljs.macros, async quantum.core.thread.async, fn quantum.core.function, quantum.core.log quantum.core.log, ns quantum.core.ns, quantum.core.logic quantum.core.logic, err quantum.core.error, quantum.core.print quantum.core.print, asyncm cljs.core.async.macros, quantum.core.thread.async quantum.core.thread.async, quantum.core.error quantum.core.error, quantum.core.collections.base quantum.core.collections.base, quantum.core.ns quantum.core.ns, quantum.core.function quantum.core.function}, :cljs.analyzer/constants {:seen #{uri :history1 :txr-alias :tries :db.part/test create-if-not-present? partitions :txr-dir table-name backend :instance-name :ephemeral :last-error :mem :txr-props-path conn :else :db-after :default-partition txr-alias :free :warn :name txr-dir :db-name instance-name :reconciler ephemeral :history :recur :type :debug :max-tries-exceeded :init-schemas? :rest-port txr-props-path :port :illegal-argument default-partition config :reactive? db-name name :db-before reconciler :host :init-partitions? :schemas history type init-schemas? rest-port port :history-limit reactive? :txr-bin-path :http :start-txr? :assertion-error :txr-process host :uri :create-if-not-present? :partitions init-partitions? schemas :table-name :backend :user txr-bin-path :dynamo history-limit start-txr? :conn txr-process}, :order [:conn :history :history-limit :reactive? :user :history1 :db-before :db-after conn history history-limit reactive? :type :name :db-name :table-name :instance-name :host :port :rest-port :uri :create-if-not-present? :start-txr? :txr-bin-path :txr-props-path :txr-dir :txr-process :txr-alias :init-partitions? :partitions :default-partition :init-schemas? :schemas :free :mem :http :dynamo :illegal-argument :debug :warn :else :max-tries-exceeded :tries :last-error :recur :assertion-error schemas :db.part/test type name db-name table-name instance-name host port rest-port uri create-if-not-present? start-txr? txr-bin-path txr-props-path txr-dir txr-process txr-alias init-partitions? partitions default-partition init-schemas? :ephemeral :reconciler :backend ephemeral reconciler backend config]}, :doc "The top level Datomic (and friends, e.g. DataScript) namespace"}